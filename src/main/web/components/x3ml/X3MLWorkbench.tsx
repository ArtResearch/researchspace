/**
 * ResearchSpace
 * Copyright (C) 2024, PHAROS: The International Consortium of Photo Archives
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import * as React from 'react';
import * as _ from 'lodash';

import 'diff-match-patch';

import 'codemirror/addon/merge/merge';
import 'codemirror/addon/merge/merge.css';

import { Button, FormControl, InputGroup, Panel, Table } from 'react-bootstrap';
import ReactSelect, { Options, Option } from 'react-select';
import * as fileSaver from 'file-saver';

import { XMLEditor } from 'platform/components/editors/XMLEditor';
import { TurtleEditorComponent } from 'platform/components/admin/repositories/TurtleEditor';
import { RDFGraphStoreService } from 'platform/api/services/rdf-graph-store';
import { CopyToClipboardComponent } from 'platform/components/copy-to-clipboard';
import { Icon } from 'platform/components/ui/icon/Icon';
import { getOverlaySystem, OverlayDialog } from 'platform/components/ui/overlay';

import * as styles from './X3MLWorkbench.scss';
import * as CodeMirror from 'codemirror';
import { DomEvent } from 'react-codemirror2';

import { calculateXPathFromPosition, evaluateMultipleXPathsOnXml } from '../editors/XPathEvaluator';
import { Rdf } from 'platform/api/rdf';
import { BuiltInEvents, trigger } from 'platform/api/events';

interface Props {
  fileName?: string;
  projectTitle?: string;
  repository?: string;
}

type AssociationTableView = {[xpath: string]: {xmlValue: string, nodeName?: string, rdfTerms: string[], absoluteXPath: string}};
interface State {
  xmlId?: string;
  xml?: string;
  parsedXml?: Document
  originalXml?: string;
  turtle?: string;
  savedToGraph?: string;

  /**
   * Array of XPath to RDF value association generated by 3M tool.
   * Each item is an object with XPath as a key and RDF value as a value.
   */
  associationTable?: [];
  associationViewTable?: AssociationTableView;
  rdfResources: Options<string>;
  selectedResource?: string;
  knowledgePatterns?: Array<string>;
}
  
export class X3MLWorkbench extends React.Component<Props, State> {
  
  private turtleEditor: CodeMirror.Editor;
  private xmlEditor: XMLEditor;

    static defaultProps = {
      readonly: false,
    }
  
    constructor(props: Props) {
      super(props);
      if (props.fileName) {
        this.state = {
          xmlId: props.fileName.substring(0, props.fileName.lastIndexOf(".")),
          rdfResources: [],
        };
      } else {
        this.state = {
          rdfResources: [],
        };
      }
    }


    // Function to parse multipart response
    private parseMultipartBody(body: string, boundary: string) {
      // Split the body to get individual parts
      const parts = body.split(`--${boundary}`);
      // Filter out the empty strings and the ending boundary
      return parts.filter(part => part.trim() !== '' && part.trim() !== '--').map(part => {
        // Extract the headers and body of each part
        const [rawHeaders, ...rest] = part.trim().split('\r\n\r\n');
        const headers = rawHeaders.split('\r\n').reduce((acc, headerLine) => {
          const [key, value] = headerLine.split(': ');
          acc[key.trim().toLowerCase()] = value.trim();
          return acc;
        }, {});
        return { headers, body: rest.join('\r\n\r\n').trim() };
      });
    }


    private fetchXML = (xmlId) => {
      const normalizedXml = `/assets/3m-app/normalized-data/${this.props.projectTitle}/${xmlId}.xml`
      const originalXml = `/assets/3m-app/raw-data/${this.props.projectTitle}/${xmlId}.xml`
      
      Promise.all([
        this.fetchXMLFile(normalizedXml),
        this.fetchXMLFile(originalXml)
      ]).then(([normalized, originalXml]) => {
        const parser = new DOMParser();
        const parsedXml = parser.parseFromString(normalized, "application/xml");
        this.setState({ xml: normalized, originalXml, parsedXml }, () => this.evalMappings());
      });
    }

    private fetchXMLFile = (fileURL) =>  {
      return fetch(fileURL).then(response => {
        // Check if the request was successful
        if (!response.ok) {
            console.error(response);
            throw new Error(
              `HTTP error! Can't get XML document from the specified url: ${fileURL}.Status: ${response.status}`
            );
        }
        return response.text();
      })
    }

    private evalMappings =  () => {
      fetch('/proxy/3m/retrieveParticipatingMappingProjectsMetadataOnly')
        .then(response => response.json())
        .then(projects => {
          const projectId = _.find(projects, {title: this.props.projectTitle})['id'];

          return fetch(`/proxy/3m/x3ml/constructAndDownloadGeneratorPolicyFileByMappingProjectId?id=${projectId}`)
            .then(r => r.blob())
            .then(generatorPolicy => ({projectId, generatorPolicy}))
        })
        .then(({projectId, generatorPolicy}) => {
          const options = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({id: projectId})
          };

          return fetch('/proxy/3m/x3ml/convertAndsaveX3mlByMappingProjectId', options)
            .then(r => r.json())
            .then(json => ({projectId, generatorPolicy, mappings: new Blob([json.x3ml], {type: 'application/x3ml'})}))
        })
        .then(({generatorPolicy, mappings}) => {
          const formData = new FormData();

          const data = new Blob([this.state.xml], { type: 'application/xml' });
          formData.append('generatorPolicy', generatorPolicy, 'generator-policy.xml');
          formData.append('mappings', mappings, 'mappings.x3ml');
          formData.append('data', data, 'data.xml');

          const options = {
            method: 'POST',
            body: formData  
          };
          return fetch('/rest/x3ml', options);
        }).then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
      
          const contentType = response.headers.get('content-type');
          const match = contentType.match(/boundary=(.*)$/);
          if (!match) {
            throw new Error('No boundary found in content type');
          }
          const boundary = match[1];
      
          return response.text().then(text => ({ text, boundary }));
        })
        .then(({ text, boundary }) => {
          const parts = this.parseMultipartBody(text, boundary);
      
          const result = { turtle: '', associationTable: null, knowledgePatterns: null };
      
          result.turtle = parts[0].body;
          result.associationTable = JSON.parse(parts[1].body);
          result.knowledgePatterns = 
            JSON.parse(parts[2].body).map(item => item['@id']);
      
          console.log('X3ML result:');
          console.log(result);

          return result;
        })
        .then(({turtle, associationTable, knowledgePatterns}) => {
          return this.convertAssociationTableToDictionary(associationTable).then(
            associationViewTable => ({turtle, associationTable, knowledgePatterns, associationViewTable})
          )

        })
        .then(({turtle, associationTable, knowledgePatterns, associationViewTable}) => {
          // we assume that RDF resources are URIs that start with http
          // that is not always correct but should cover most cases
          // we use these values only in the resource selector 
          // for opening a page for the given rousource
          const rdfResources =
            _.uniq(
              associationTable.map(item => _.values(item)[0])
            )
            .filter((item: string) => item.startsWith('http'))
            .map((item: string) => ({value: item, label: item}));

          this.setState({turtle, associationTable, associationViewTable, rdfResources, knowledgePatterns})
        });
    }
    private async convertAssociationTableToDictionary(arr: Array<{[key: string]: string}>): Promise<AssociationTableView> {
      const result: any = {};
    
      arr.forEach((obj) => {
        const [key, value] = Object.entries(obj)[0];
        const transformedXPath = this.getModifiedXPath(key);
        if (result[transformedXPath]) {
          result[transformedXPath].rdfTerms.push(value);
        } else {
          result[transformedXPath] = {rdfTerms: [value], nodeName: '', xmlValue: ''};
        }
      });
    
      const xPathResults = await evaluateMultipleXPathsOnXml(this.state.xml, Object.keys(result));
      xPathResults.forEach(resultItem => {
        const {xpath, text, nodeName, absoluteXPath} = resultItem;
        result[xpath].nodeName = nodeName;
        result[xpath].xmlValue = text;
        result[xpath].absoluteXPath = absoluteXPath;

      });
    
      return result as AssociationTableView;
    }
    
    private xmlOnMouseDown: DomEvent = async (cm: any, event) => {
      const pos = cm.coordsChar({ left: event.pageX, top: event.pageY });
      const token = cm.getTokenAt(pos);
    
      const selectedNodeXPath = await calculateXPathFromPosition(this.state.xml, { line: pos.line, offset: token.start });
      
      const allXPathes = _.uniq(this.state.associationTable.map(item => _.keys(item)[0]));
      const xpathsToMatch = this.stripXPathFunctions(allXPathes);
    
      const selectedNode = this.state.parsedXml.evaluate(selectedNodeXPath, this.state.parsedXml, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
    
      const matchedAssociations = xpathsToMatch.filter(item => {
        const possiblySelectedXPath = _.keys(item)[0];
        const iter = this.state.parsedXml.evaluate(possiblySelectedXPath, this.state.parsedXml, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
        for (let i = 0; i < iter.snapshotLength; i++) {
          if (iter.snapshotItem(i) === selectedNode) {
            return true;
          }
        }
        return false;
      });
    
      const rdfValues: Array<string> =
        _.uniq(
          _.flatten(
            matchedAssociations
              .map(item => _.values(item)[0])
              .map(
                key => this.state.associationTable
                         .filter(item => _.keys(item)[0] == key)
                        .map(item => _.values(item)[0] as string)
              )
          )
        )
    
      this.highlightRdfTerms(rdfValues);
      this.xmlEditor.highlightXPaths([selectedNodeXPath]);
    }

    componentDidMount() {
      if (this.state.xmlId) {
        this.fetchXML(this.state.xmlId);
      }
    }

    private highlightRdfTerms = (rdfTerms: Array<string>) => {
      const toHighlight =
        _.flattenDeep(
          rdfTerms.map(v => this.findStringOccurrences(this.state.turtle, v))
        );
      
      // Remove previous highlights
      this.turtleEditor.getAllMarks().forEach(mark => mark.clear());

      toHighlight.forEach(({startLine, startOffset, endLine, endOffset}) => {
        const startPos = { line: startLine, ch: startOffset };
        const endPos = { line: endLine, ch: endOffset };
        // Mark the text range in CodeMirror
        this.turtleEditor.markText(startPos, endPos, { className: 'highlighted-text' });
      });

    }

    private turtleOnMouseDown: DomEvent = (cm, event) => {
      const selectedRdfItem = this.stripEnclosingAngleBrackets(event.target.textContent);
      this.highlightXmlElementForRdfTerm(selectedRdfItem);
    };

    private highlightXmlElementForRdfTerm = (rdfTerm: string) => {
      const xpaths = 
        this.state.associationTable
          .filter(item => _.values(item)[0] === rdfTerm)
          .map(item => _.keys(item)[0]);  

      // association table item from X3ML engine can contain xpaths that ends with function
      // but we need to get the actual XML element that belongs to this xpath so we can highlight it
      const xpathsToHighlight = this.stripXPathFunctions(xpaths).map(item => _.keys(item)[0]);
      this.xmlEditor.highlightXPaths(xpathsToHighlight);
    }

    private stripXPathFunctions = (xpathes: Array<string>) => {
      return xpathes.map(xpath => {    
        const modifiedXPath = this.getModifiedXPath(xpath);    
        return {[modifiedXPath]: xpath};
      });
    }

    /**
     * We need to rewrite xpath to strip last function call 
     * so we can use it to get actuall XML element that belongs to this xpath.
     */
    private getModifiedXPath = (xpath: string): string => {

      const functionCallPattern = /^[a-z]+\(.*\)$/;
      if (functionCallPattern.test(xpath)) {
        // if the whole xpath is a function call then we need to extract the actual node that this xpath points to
        // here we assume that inside the xpath there is a path with text() call
        const nestedTextPathPattern = /((\.\.\/|\.\/)?[^(]*)\/text\(\)/;
        const match = nestedTextPathPattern.exec(xpath);
        return match[1];
      } else {
        let parenthesisBalance = 0;
        let functionStartIndex = -1;
    
        // Iterate backwards through the string
        for (let i = xpath.length - 1; i >= 0; i--) {
          if (xpath[i] === ')') {
            parenthesisBalance++;
          } else if (xpath[i] === '(') {
            parenthesisBalance--;
            if (parenthesisBalance === 0) {
              // Found the start of the outermost function
              functionStartIndex = i;
              break;
            }
          }
        }
    
        let modifiedXpath = xpath;
        if (functionStartIndex !== -1) {
          // Find the last '/' before the start of the function
          const lastSlashIndex = xpath.lastIndexOf('/', functionStartIndex - 1);
          if (lastSlashIndex !== -1) {
            modifiedXpath = xpath.substring(0, lastSlashIndex);
          }
        }
        return modifiedXpath;
      }
     };

    // Function to strip angle brackets if the entire string is enclosed in them
    private stripEnclosingAngleBrackets(text: string): string {
      // Regular expression to match strings that start and end with angle brackets
      const match = text.match(/^<(.*)>$/);

      // If there's a match, return the first capturing group, otherwise return the original string
      return match ? match[1] : text;
    }

    public render() {
      if (this.state.xml) {
        return (
          <div className={styles.holder}>
            <div className={styles.column}>
              <div className={styles.fileInputHolder}>
                <FormControl
                  type="text"
                  value={this.state.xmlId}
                  placeholder='xml file id'
                  onChange={this.onXmlIdChange}
                />
                <Button bsStyle='primary' className={styles.inputButton} onClick={this.onLoadXmlClick}>
                  Load File &nbsp; <Icon iconType='round' iconName='search' className='text-muted' />
                </Button>
                <Button bsStyle='primary' className={styles.actionButton}
                  onClick={this.onDiffWithOriginal}>
                    Compare to Original &nbsp; <Icon iconType='round' iconName='difference' className='text-muted'/>
                </Button>
                          
                <Button bsStyle='primary' className={styles.actionButton} onClick={this.onXmlDownload} title='Download'>
                  <Icon iconType='round' iconName='download' className='text-muted'/>
                </Button>
                <CopyToClipboardComponent text={this.state.xml}>
                  <Button bsStyle='primary' className={styles.actionButton} title='Copy'>
                    <Icon iconType='round' iconName='content_copy' className='text-muted'/>
                  </Button>
                </CopyToClipboardComponent>
              </div>
              <XMLEditor 
                ref={ref => ref ? this.xmlEditor = ref : null} 
                content={this.state.xml} onMouseDown={this.xmlOnMouseDown}
              />
            </div>
            {
              this.state.turtle ? this.turtleView() : <div></div>
            }
          </div>
        );
      } else {
        return 'Loading...'
      }
    }

    private turtleView(): JSX.Element {
      const { rdfResources, selectedResource, savedToGraph } = this.state;
      return (
        <div className={styles.column}>
          <div className={styles.fileInputHolder}>
            <ReactSelect
              options={rdfResources}
              value={selectedResource}
              multi={false}
              onChange={(selected: Option<string>) => this.setState({selectedResource: selected?.value})}
              placeholder='select URI'
            />
            <Button bsStyle='primary' className={styles.inputButton}
              onClick={this.showResource} disabled={savedToGraph && selectedResource ? false : true}>
              Show Resource  &nbsp; <Icon iconType='round' iconName='description' className='text-muted' />
            </Button>
            <Button bsStyle='primary' className={styles.actionButton} onClick={this.onRdfReload}>
               Reload &nbsp; <Icon iconType='round' iconName='cached' className='text-muted'/>
            </Button>
            <Button bsStyle='primary' className={styles.actionButton} onClick={this.onSaveRdfToRepo} title='Save to Test Repository'>
              Save &nbsp; <Icon iconType='round' iconName='cloud_upload' className='text-muted'/>
            </Button>
            {this.showRunQueryButton()}
            <Button bsStyle='primary' className={styles.actionButton}  onClick={this.onRdfDownload}>
              <Icon iconType='round' iconName='download' className='text-muted'/>
            </Button>
            <CopyToClipboardComponent text={this.state.turtle}>
              <Button bsStyle='primary' className={styles.actionButton} title='Copy'>
                <Icon iconType='round' iconName='content_copy' className='text-muted'/>
              </Button>
            </CopyToClipboardComponent>
          </div>

          <Panel className={styles.associationTableView}>
            {this.state.associationViewTable && (
              <Table condensed hover responsive>
                <thead>
                </thead>
                <tbody>
                {
                _.map(this.state.associationViewTable, ({xmlValue, nodeName, rdfTerms}, xpath) => (
                  <tr key={xpath}>
                    <td>
                    <Button bsStyle='link' key={xpath} onClick={this.onXmlElementClick(xpath, rdfTerms)}>
                      {/* in association view table UI we are showing tag name instead of the tag content if the content is too big */}
                      <span className={styles.associationTableResultHeader}>{xmlValue.length > 100 ? nodeName : xmlValue}</span>
                    </Button>
                    </td>
                    <td>
                      <div className={styles.associationTableViewItem}>
                      {
                        rdfTerms.map((rdfValue, j) => 
                          <Button bsStyle='link' key={j} onClick={this.onRdfTermClick(xpath, rdfValue)}>
                            {rdfValue}
                          </Button>
                        )
                      }
                      </div>
                    </td>
                  </tr>
                ))
                }
                </tbody>
              </Table>
            )}
          </Panel>


          <div className={styles.rdfEditorAreaHolder}>
            <TurtleEditorComponent 
              ref={ref => ref ? this.turtleEditor = ref.editor : null} 
              onMouseDown={this.turtleOnMouseDown}
              turtleString={this.state.turtle} />
          </div>
        </div>
      );
  }

  private onRdfTermClick = (xpath: string, rdfTerm: string) => () => {
    this.xmlEditor.highlightXPaths([xpath]);
    this.xmlEditor.scrollToXPath(xpath);
    this.highlightRdfTerms([rdfTerm]);
  }

  private onXmlElementClick = (xpath: string, rdfTerms: string[]) => () => {
    this.xmlEditor.highlightXPaths([xpath]);
    this.xmlEditor.scrollToXPath(xpath);
    this.highlightRdfTerms(rdfTerms);
  }

  private onXmlDownload = () => {
    const fileName = this.props.fileName || 'data.xml';
    const blob = new Blob([this.state.xml], { type: 'application/xml' });
    fileSaver.saveAs(blob, fileName);
  }

  private onDiffWithOriginal = () => {
    const dialogRef = `xml-diff-dialog`;

    getOverlaySystem().show(
      dialogRef,
      <OverlayDialog 
        onHide={() => getOverlaySystem().hide(dialogRef)}
        type='lightbox'
        title='Diff Normalized XML with Original XML'
        show={true}
      >
        <div ref={this.onDiffWithOriginalLoaded} className={styles.mergeView}>
        </div>
      </OverlayDialog>
    );
  }

  private onDiffWithOriginalLoaded = (ref: HTMLElement) => {
    if (ref) {
      CodeMirror.MergeView(ref, {
        value: this.normalizeAttributes(this.state.xml),
        orig: this.normalizeAttributes(this.state.originalXml),
        lineNumbers: true,
        mode: 'text/xml',
        connect: 'align',
        collapseIdentical: 1,
      });
    }
  }

  /**
   * Normalize the attributes of an XML string by sorting them alphabetically.
   * We need to do it to improve the diff view, because according to XML standard
   * order of attributes doesn't matter.
   * And there is no guarantee that even the same serializer will produce the same order,
   * so as result we get very ugly diffs.
   */
  private normalizeAttributes(xmlString: string) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, "text/xml");
    this.sortAttributes(xmlDoc.documentElement);
  
    const serializer = new XMLSerializer();
    return serializer.serializeToString(xmlDoc);
  }

  private sortAttributes(element: Element) {
    // Collect all attributes
    const attributes = {};
    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];
      attributes[attr.name] = attr.value;
    }

    // Sort attribute names
    const sortedAttributeNames = Object.keys(attributes).sort();

    // Clear all attributes
    sortedAttributeNames.forEach(name => element.removeAttribute(name));

    // Set attributes in sorted order
    for (const name of sortedAttributeNames) {
      element.setAttribute(name, attributes[name]);
    }

    // Recurse for child elements
    element.childNodes.forEach(child => {
      if (child.nodeType === 1) { // Element node
        this.sortAttributes(child as Element);
      }
    });
  }

  private onXmlIdChange = (event: React.FormEvent<FormControl>) => {
    this.setState({
      xmlId: (event.target as HTMLInputElement).value
    });
  }

  private onLoadXmlClick = () => {
    this.fetchXML(this.state.xmlId);
  }

  private showResource = () => {
    trigger({
      eventType: BuiltInEvents.ComponentTemplateUpdate,
      source: 'x3ml-editor',
      targets: ['x3ml-resource-view'],
      data: {
        iri: this.state.selectedResource,
        knowledgePatterns: this.state.knowledgePatterns,
        repository: this.props.repository,
        defaultGraph: this.state.savedToGraph
      },
    });

  }
  
  private showRunQueryButton = () => {
    const { repository } = this.props;
    const query = `
SELECT * 
FROM <${this.state.savedToGraph}> 
WHERE {
  ?s ?p ?o
}
    `
    const url = `/sparql?query=${encodeURIComponent(query)}&repository=${repository}`;
    return (
      <Button 
        bsStyle='primary'
        disabled={this.state.savedToGraph ? false : true} 
        className={styles.actionButton} 
        onClick={() => window.open(url, '_blank')}
      >
        SPARQL &nbsp; <Icon iconType='round' iconName='play_circle' className='text-muted'/>
      </Button>
    );
  };

  private onRdfReload = () => {
    this.evalMappings();
  }

  private onRdfDownload = () => {
    const fileName = this.props.fileName + '.ttl' || 'data.ttl';
    const blob = new Blob([this.state.turtle], { type: 'text/turtle' });
    fileSaver.saveAs(blob, fileName);
  }

  private onSaveRdfToRepo = () => {
    const targetGraph = 
      Rdf.iri(
        window.location.protocol + '//' + window.location.host 
        + '/resource/graph-' + encodeURIComponent((new Date()).toISOString())
      );
    RDFGraphStoreService.createGraphRequest({
      targetGraph, turtleString: this.state.turtle, repository: this.props.repository
    }).onValue((savedToGraph) => {
      this.setState({savedToGraph})
    })
  }

    // utility functions
  private findStringOccurrences(document: string, searchString: string): { startLine: number, startOffset: number, endLine: number, endOffset: number }[] {
      // Check if the searchString is empty
      if (searchString === '' || document === '') {
          return [];
      }
  
      const matches: { startLine: number, startOffset: number, endLine: number, endOffset: number }[] = [];
      
      let matchIndex = document.indexOf(searchString);
  
      // Function to calculate line and offset for a given index
      function calculateLineAndOffset(index: number) {
          const linesUpToIndex = document.substring(0, index).split('\n');
          const line = linesUpToIndex.length - 1;
          const offset = linesUpToIndex[linesUpToIndex.length - 1].length;
          return { line, offset };
      }
  
      // Loop to find all occurrences in the document
      while (matchIndex !== -1) {
          const matchEndIndex = matchIndex + searchString.length;
  
          // Calculate start and end line and offsets for the match
          const { line: startLine, offset: startOffset } = calculateLineAndOffset(matchIndex);
          const { line: endLine, offset: endOffset } = calculateLineAndOffset(matchEndIndex);
  
          matches.push({ startLine, startOffset, endLine, endOffset });
  
          // Find next occurrence in the document
          matchIndex = document.indexOf(searchString, matchIndex + searchString.length);
      }
  
      return matches;
  }
  
}

export default X3MLWorkbench;